<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple Chess Board with AI</title>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #eee;
      flex-direction: column;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 4px solid #333;
    }
    .cell {
      width: 60px;
      height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      user-select: none;
    }
    .light {
      background-color: #f0d9b5;
    }
    .dark {
      background-color: #b58863;
    }
    .highlight {
      outline: 2px solid yellow;
    }
    #status {
      margin: 10px;
      font-weight: bold;
      font-size: 1.2rem;
    }
  </style>
</head>
<body>
  <div id="status"></div>
  <div id="board"></div>
  <script>
    const boardEl = document.getElementById("board");
    const statusEl = document.getElementById("status");
    const initialBoard = [
      ["r", "n", "b", "q", "k", "b", "n", "r"],
      ["p", "p", "p", "p", "p", "p", "p", "p"],
      ["", "", "", "", "", "", "", ""],
      ["", "", "", "", "", "", "", ""],
      ["", "", "", "", "", "", "", ""],
      ["", "", "", "", "", "", "", ""],
      ["P", "P", "P", "P", "P", "P", "P", "P"],
      ["R", "N", "B", "Q", "K", "B", "N", "R"]
    ];

    const pieces = {
      r: "‚ôú", n: "‚ôû", b: "‚ôù", q: "‚ôõ", k: "‚ôö", p: "‚ôü",
      R: "‚ôñ", N: "‚ôò", B: "‚ôó", Q: "‚ôï", K: "‚ôî", P: "‚ôô"
    };

    let selectedCell = null;

    function isWhite(piece) {
      return piece && piece === piece.toUpperCase();
    }

    function isValidMove(fromRow, fromCol, toRow, toCol) {
      const piece = initialBoard[fromRow][fromCol];
      const target = initialBoard[toRow][toCol];
      if (!piece) return false;
      if (target && isWhite(piece) === isWhite(target)) return false;

      const dx = toCol - fromCol;
      const dy = toRow - fromRow;
      const absDx = Math.abs(dx);
      const absDy = Math.abs(dy);

      switch (piece.toLowerCase()) {
        case 'p': {
          const dir = isWhite(piece) ? -1 : 1;
          const startRow = isWhite(piece) ? 6 : 1;
          if (dx === 0 && !target) {
            if (dy === dir) return true;
            if (fromRow === startRow && dy === 2 * dir && !initialBoard[fromRow + dir][fromCol]) return true;
          }
          if (absDx === 1 && dy === dir && target) return true;
          return false;
        }
        case 'r': return (dx === 0 || dy === 0) && clearPath(fromRow, fromCol, toRow, toCol);
        case 'n': return (absDx === 1 && absDy === 2) || (absDx === 2 && absDy === 1);
        case 'b': return absDx === absDy && clearPath(fromRow, fromCol, toRow, toCol);
        case 'q': return ((dx === 0 || dy === 0) || (absDx === absDy)) && clearPath(fromRow, fromCol, toRow, toCol);
        case 'k': return absDx <= 1 && absDy <= 1;
      }
      return true;
    }

    function clearPath(fromRow, fromCol, toRow, toCol) {
      const rowStep = Math.sign(toRow - fromRow);
      const colStep = Math.sign(toCol - fromCol);
      let r = fromRow + rowStep;
      let c = fromCol + colStep;
      while (r !== toRow || c !== toCol) {
        if (initialBoard[r][c] !== "") return false;
        r += rowStep;
        c += colStep;
      }
      return true;
    }

    function drawBoard() {
      boardEl.innerHTML = "";
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const cell = document.createElement("div");
          cell.classList.add("cell", (row + col) % 2 === 0 ? "light" : "dark");
          cell.dataset.row = row;
          cell.dataset.col = col;
          const piece = initialBoard[row][col];
          cell.textContent = pieces[piece] || "";
          if (piece && isWhite(piece)) {
            cell.draggable = true;
            cell.addEventListener("dragstart", (e) => {
              selectedCell = { row, col };
            });
          }
          cell.addEventListener("dragover", (e) => e.preventDefault());
          cell.addEventListener("drop", (e) => {
            if (selectedCell) {
              const fromRow = selectedCell.row;
              const fromCol = selectedCell.col;
              const toRow = parseInt(cell.dataset.row);
              const toCol = parseInt(cell.dataset.col);
              if (isValidMove(fromRow, fromCol, toRow, toCol)) {
                initialBoard[toRow][toCol] = initialBoard[fromRow][fromCol];
                initialBoard[fromRow][fromCol] = "";
                drawBoard();
                setTimeout(() => {
                  makeAIMove();
                  checkGameStatus();
                }, 300);
              }
            }
          });
          boardEl.appendChild(cell);
        }
      }
      checkGameStatus();
    }


// ---- SMART AI: minimax (alpha-beta), move ordering, king safety ----

// Tunable search depth (3 = strong medium, 2 = faster) ü§ñü§ñü§ñü§ñü§ñü§ñü§ñü§ñ


const SEARCH_DEPTH = 3;

// cheap piece value map for ordering/eval
function pieceBaseValue(piece) {
  if (!piece) return 0;
  const map = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 1000 };
  return map[piece.toLowerCase()] || 0;
}

// make a shallow copy of board (rows copied)
function copyBoard(board) {
  return board.map(row => row.slice());
}

// find king coords on a given board for color
function findKingOnBoard(board, isWhiteKing) {
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      if (p && p.toLowerCase() === 'k' && isWhite(p) === isWhiteKing) {
        return [r, c];
      }
    }
  }
  return null;
}

// check if a king is in check on a given board
function isKingInCheckBoard(board, isWhiteKing) {
  const kingPos = findKingOnBoard(board, isWhiteKing);
  if (!kingPos) return false;
  const [kr, kc] = kingPos;

  // We need to ask isValidMove for each enemy piece -> that function reads global initialBoard.
  // Temporarily swap global board, call isValidMove, then restore.
  const oldBoard = initialBoard;
  initialBoard = board;
  try {
    for (let r = 0; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        const piece = board[r][c];
        if (!piece) continue;
        if (isWhite(piece) === isWhiteKing) continue; // same color
        if (isValidMove(r, c, kr, kc)) {
          initialBoard = oldBoard;
          return true;
        }
      }
    }
  } finally {
    initialBoard = oldBoard;
  }
  return false;
}

// generate moves for given board & side. Uses isValidMove temporarily by swapping global board.
function generateMovesForBoard(board, isWhiteSide) {
  const oldBoard = initialBoard;
  initialBoard = board;
  const moves = [];
  try {
    for (let r1 = 0; r1 < 8; r1++) {
      for (let c1 = 0; c1 < 8; c1++) {
        const piece = board[r1][c1];
        if (!piece) continue;
        if (isWhite(piece) !== isWhiteSide) continue;
        for (let r2 = 0; r2 < 8; r2++) {
          for (let c2 = 0; c2 < 8; c2++) {
            if (isValidMove(r1, c1, r2, c2)) {
              moves.push({
                from: [r1, c1],
                to: [r2, c2],
                piece: piece,
                captured: board[r2][c2] || ""
              });
            }
          }
        }
      }
    }
  } finally {
    initialBoard = oldBoard;
  }

  // Order moves: captures (by descending value) first, then quieter moves.
  moves.sort((a, b) => {
    const va = pieceBaseValue(a.captured);
    const vb = pieceBaseValue(b.captured);
    return vb - va; // higher capture value earlier
  });

  return moves;
}

// apply move to board (mutates board), store piece/captured on move object for undo
function applyMoveOnBoard(board, move) {
  const [fr, fc] = move.from;
  const [tr, tc] = move.to;
  move._captured = board[tr][tc]; // save for undo
  move._moved = board[fr][fc];
  board[tr][tc] = board[fr][fc];
  board[fr][fc] = "";
}

// undo previously applied move
function undoMoveOnBoard(board, move) {
  const [fr, fc] = move.from;
  const [tr, tc] = move.to;
  board[fr][fc] = move._moved;
  board[tr][tc] = move._captured;
  delete move._moved;
  delete move._captured;
}

// simple material evaluation (white positive, black negative)
function evaluateBoardMaterial(board) {
  let score = 0;
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      if (!p) continue;
      const v = pieceBaseValue(p);
      score += isWhite(p) ? v : -v;
    }
  }
  return score;
}

// minimax with alpha-beta. isMaximizing = true => it's White's turn to move (maximizes score).
function minimaxAB(board, depth, alpha, beta, isMaximizing) {
  // terminal or depth 0
  if (depth === 0) return evaluateBoardMaterial(board);

  // generate moves for current side
  const moves = generateMovesForBoard(board, isMaximizing); // true => white moves
  if (moves.length === 0) {
    // no moves: return evaluation (we don't currently detect checkmate vs stalemate separately)
    return evaluateBoardMaterial(board);
  }

  if (isMaximizing) {
    let value = -Infinity;
    for (const mv of moves) {
      applyMoveOnBoard(board, mv);

      // prune illegal positions where white king is in check after white's move (shouldn't happen if isValidMove prohibits)
      if (!isKingInCheckBoard(board, true)) {
        value = Math.max(value, minimaxAB(board, depth - 1, alpha, beta, false));
        alpha = Math.max(alpha, value);
      }

      undoMoveOnBoard(board, mv);
      if (alpha >= beta) break; // beta cutoff
    }
    return value;
  } else {
    let value = Infinity;
    for (const mv of moves) {
      applyMoveOnBoard(board, mv);

      if (!isKingInCheckBoard(board, false)) {
        value = Math.min(value, minimaxAB(board, depth - 1, alpha, beta, true));
        beta = Math.min(beta, value);
      }

      undoMoveOnBoard(board, mv);
      if (alpha >= beta) break;
    }
    return value;
  }
}

// MAIN: improved makeAIMove ‚Äî uses minimaxAB to pick move, protects king
function makeAIMove() {
  // generate black moves on current board
  const moves = generateMovesForBoard(initialBoard, false);
  if (moves.length === 0) return;

  // First: if king is currently in check, collect only moves that remove check
  let legalMoves = [];
  if (isKingInCheckBoard(initialBoard, false)) {
    for (const mv of moves) {
      const boardCopy = copyBoard(initialBoard);
      applyMoveOnBoard(boardCopy, mv);
      if (!isKingInCheckBoard(boardCopy, false)) legalMoves.push(mv);
    }
    // If found safe moves, use those only; otherwise fall back to all moves (no escape)
    if (legalMoves.length === 0) legalMoves = moves;
  } else {
    // not in check: exclude moves that leave king in check
    for (const mv of moves) {
      const boardCopy = copyBoard(initialBoard);
      applyMoveOnBoard(boardCopy, mv);
      if (!isKingInCheckBoard(boardCopy, false)) legalMoves.push(mv);
    }
    if (legalMoves.length === 0) legalMoves = moves; // fallback
  }

  // Evaluate each candidate move with minimax (simulate move, then run minimax)
  let bestScore = Infinity; // black wants to minimize material (white positive, black negative)
  let bestMoves = [];

  for (const mv of legalMoves) {
    // apply on a copy
    const boardCopy = copyBoard(initialBoard);
    applyMoveOnBoard(boardCopy, mv);

    // run minimax: after black moves, it's White's turn => maximizer
    const score = minimaxAB(boardCopy, SEARCH_DEPTH - 1, -Infinity, Infinity, true);

    // Since evaluate returns white-positive values, black prefers smaller scores
    if (score < bestScore - 1e-6) {
      bestScore = score;
      bestMoves = [mv];
    } else if (Math.abs(score - bestScore) < 1e-6) {
      bestMoves.push(mv);
    }
  }

  // pick randomly among best moves to add variety
  const chosen = bestMoves[Math.floor(Math.random() * bestMoves.length)];

  // apply chosen move to actual board
  if (chosen) {
    applyMoveOnBoard(initialBoard, chosen);
    drawBoard();
  }
}


// 

    function checkGameStatus() {
      let whiteKing = false;
      let blackKing = false;
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const piece = initialBoard[row][col];
          if (piece === 'K') whiteKing = true;
          if (piece === 'k') blackKing = true;
        }
      }
      if (!whiteKing) {
        statusEl.textContent = "üè¥ Black wins!";
      } else if (!blackKing) {
        statusEl.textContent = "üè≥Ô∏è White wins!";
      } else {
        statusEl.textContent = "‚ôü Game in progress...";
      }
    }

    drawBoard();
  </script>
</body>
</html> 

